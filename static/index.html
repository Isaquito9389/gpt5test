<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Port Scanner Pro</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f4f4f4;
        }

        h1 {
            text-align: center;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            margin: auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-top: 15px;
        }

        input,
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #0056b3;
        }

        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            color: #155724;
        }
    </style>
</head>

<body>
    <h1>Port Scanner Pro</h1>
    <div class="card">
        <div class="status success">
            <strong>‚úÖ Service op√©rationnel</strong> - Scanner de ports configur√© avec les variables d'environnement
            Render
        </div>
        <label>H√¥te / IP :</label>
        <input type="text" id="ip" placeholder="Ex: google.com, www.github.com, https://example.com, 8.8.8.8">
        <small style="color: #666; font-size: 12px;">
            ‚ÑπÔ∏è Supporte les domaines avec/sans www, suit les redirections automatiquement
        </small>

        <label>Plage de ports :</label>
        <input type="text" id="ports" placeholder="Ex: 1-1024 ou 22,80,443" value="1-1024">

        <label>Niveau de scan :</label>
        <select id="scanLevel" style="width: 100%; padding: 10px; margin-top: 5px;">
            <option value="basic">üü¢ Basique - Rapide et discret</option>
            <option value="advanced">üü° Avanc√© - D√©tection de services et OS</option>
            <option value="expert">üî¥ Expert - Scripts + Bypass CDN</option>
            <option value="stealth">üü£ Furtif - √âvite la d√©tection</option>
        </select>
        <small style="color: #666; font-size: 12px;">
            ‚ö†Ô∏è Les niveaux Expert/Furtif peuvent prendre plus de temps
        </small>

        <button onclick="scan()">Lancer le scan</button>
        <button onclick="testResolve()" style="background: #17a2b8; margin-top: 10px;">Test R√©solution DNS</button>
        <button onclick="testConfig()" style="background: #6c757d; margin-top: 10px;">Test Configuration</button>

        <h3>R√©sultat :</h3>
        <pre id="result">En attente...</pre>
    </div>

    <script src="/static/config.js"></script>
    <script>
        function formatScanResults(data) {
            let output = "";
            
            // En-t√™te avec informations de r√©solution
            output += "üéØ R√âSULTATS DU SCAN\n";
            output += "‚ïê".repeat(50) + "\n\n";
            
            output += `üìç H√¥te original: ${data.original_host}\n`;
            output += `üåê H√¥te r√©solu: ${data.resolved_host}\n`;
            output += `üéØ IP cible: ${data.target_ip}\n`;
            output += `üìä Niveau de scan: ${data.scan_level.toUpperCase()}\n`;
            output += `üîç Ports scann√©s: ${data.scanned_ports}\n`;
            
            if (data.is_behind_cdn) {
                output += `‚òÅÔ∏è CDN d√©tect√©: Cloudflare/CDN (IP masqu√©e)\n`;
                if (data.host_info && data.host_info.fallback_used) {
                    output += `üîÑ Scan de fallback utilis√© pour contourner les protections CDN\n`;
                }
            }
            
            output += "\n";
            
            // Informations sur l'h√¥te
            if (data.host_info && Object.keys(data.host_info).length > 0) {
                output += "üñ•Ô∏è INFORMATIONS SYST√àME\n";
                output += "‚îÄ".repeat(30) + "\n";
                if (data.host_info.status) {
                    output += `Status: ${data.host_info.status}\n`;
                }
                if (data.host_info.os) {
                    output += `OS d√©tect√©: ${data.host_info.os.name} (${data.host_info.os.accuracy}% confiance)\n`;
                }
                output += "\n";
            }
            
            // IPs r√©elles trouv√©es derri√®re CDN
            if (data.real_ips_found && data.real_ips_found.length > 0) {
                output += "üïµÔ∏è IPS R√âELLES TROUV√âES (Bypass CDN)\n";
                output += "‚îÄ".repeat(40) + "\n";
                data.real_ips_found.forEach(realIp => {
                    output += `‚Ä¢ ${realIp.method}: ${realIp.ip} (${realIp.host})\n`;
                });
                output += "\n";
            }
            
            // Ports ouverts
            if (data.open_ports && data.open_ports.length > 0) {
                output += `üö™ PORTS OUVERTS (${data.open_ports.length} trouv√©s)\n`;
                output += "‚îÄ".repeat(35) + "\n";
                
                data.open_ports.forEach(port => {
                    const serviceIcon = getServiceIcon(port.port);
                    output += `${serviceIcon} Port ${port.port}/${port.protocol}\n`;
                    
                    if (port.service && port.service.name) {
                        output += `   Service: ${port.service.name}`;
                        if (port.service.product) {
                            output += ` (${port.service.product}`;
                            if (port.service.version) {
                                output += ` ${port.service.version}`;
                            }
                            output += ")";
                        }
                        output += "\n";
                        
                        if (port.service.extrainfo) {
                            output += `   Info: ${port.service.extrainfo}\n`;
                        }
                    }
                    
                    // Scripts NSE
                    if (port.scripts && port.scripts.length > 0) {
                        output += `   üîç Scripts NSE:\n`;
                        port.scripts.forEach(script => {
                            output += `     ‚Ä¢ ${script.id}:\n`;
                            const scriptOutput = script.output.split('\n').slice(0, 3).join('\n');
                            output += `       ${scriptOutput}\n`;
                        });
                    }
                    
                    output += "\n";
                });
            } else {
                output += "üö™ PORTS OUVERTS\n";
                output += "‚îÄ".repeat(20) + "\n";
                output += "Aucun port ouvert trouv√© dans la plage scann√©e.\n\n";
            }
            
            // Informations techniques
            output += "üîß INFORMATIONS TECHNIQUES\n";
            output += "‚îÄ".repeat(30) + "\n";
            output += `Code de sortie nmap: ${data.nmap_exit_code}\n`;
            output += `Timestamp: ${new Date().toLocaleString()}\n`;
            
            return output;
        }
        
        function getServiceIcon(port) {
            const icons = {
                21: "üìÅ", 22: "üîê", 23: "üíª", 25: "üìß", 53: "üåê",
                80: "üåç", 110: "üì¨", 143: "üìÆ", 443: "üîí", 993: "üîê",
                995: "üîê", 3389: "üñ•Ô∏è", 5432: "üóÑÔ∏è", 3306: "üóÑÔ∏è"
            };
            return icons[port] || "üîå";
        }

        async function scan() {
            const ip = document.getElementById("ip").value.trim();
            const ports = document.getElementById("ports").value.trim();
            const scanLevel = document.getElementById("scanLevel").value;
            
            if (!ip) {
                alert("Veuillez entrer un h√¥te ou une IP");
                return;
            }

            const resultDiv = document.getElementById("result");
            resultDiv.textContent = `Scan ${scanLevel} en cours...\n‚è≥ Cela peut prendre quelques minutes selon le niveau choisi.`;
            
            try {
                const requestBody = { 
                    ip: ip,
                    scan_level: scanLevel
                };
                if (ports) {
                    requestBody.ports = ports;
                }

                console.log("Sending request:", requestBody);

                const res = await fetch(window.API_CONFIG.API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-API-KEY": window.API_CONFIG.API_KEY
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({ error: "Unknown error" }));
                    throw new Error(`HTTP ${res.status}: ${errorData.error || res.statusText}`);
                }

                const data = await res.json();
                resultDiv.textContent = formatScanResults(data);
            } catch (err) {
                resultDiv.textContent = "Erreur: " + err.message;
                console.error("Scan error:", err);
            }
        }

        async function testResolve() {
            const ip = document.getElementById("ip").value.trim();
            if (!ip) {
                alert("Veuillez entrer un h√¥te pour tester la r√©solution");
                return;
            }

            document.getElementById("result").textContent = "Test de r√©solution DNS...";
            try {
                const res = await fetch("/resolve", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ host: ip })
                });

                const data = await res.json();
                document.getElementById("result").textContent = "R√©solution DNS:\n" + JSON.stringify(data, null, 2);
            } catch (err) {
                document.getElementById("result").textContent = "Erreur r√©solution: " + err.message;
            }
        }

        async function testConfig() {
            document.getElementById("result").textContent = "Test de configuration...";
            try {
                const res = await fetch("/debug");
                const data = await res.json();
                document.getElementById("result").textContent = "Configuration:\n" + JSON.stringify(data, null, 2) + 
                    "\n\nAPI Key (frontend): " + (window.API_CONFIG.API_KEY ? "Configur√©e (" + window.API_CONFIG.API_KEY.length + " chars)" : "Non configur√©e");
            } catch (err) {
                document.getElementById("result").textContent = "Erreur test config: " + err.message;
            }
        }
    </script>
</body>

</html>